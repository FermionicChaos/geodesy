#pragma once
#ifndef GEODESY_ENGINE_H
#define GEODESY_ENGINE_H

// ----- Core Libraries of the Geodesy Engine ----- //

// Engine Configuration
#include "config.h"

// Core components.
#include "core/io.h"
#include "core/math.h"
#include "core/util.h"
#include "core/lgc.h"
#include "core/phys.h"
#include "core/hid.h"
#include "core/gcl.h"
#include "core/gfx.h"
#include "core/sfx.h"

// Base objects which the game engine processes.
#include "ecs/object.h"
#include "ecs/subject.h"
#include "ecs/stage.h"
#include "ecs/app.h"

// The geodesy engine is an engine that is a multi-threaded high performance engine
// designed for high performance games and simulations. The resources and data the
// engine is responsible for is File management, and the creation and destruction of
// vulkan logical devices, and by consequence all contexts. All files are host memory
// representations of data before being loaded into any particular context's device
// memory. First this prevents double loading of files that are already loaded into
// memory, and secondly, it allows for any object_t or stage_t to reference the 
// same data for the creation of their respective objects. The engine also manages
// all device contexts ever created. This is necessary so that the engine may also 
// process all vulkan commands generated by either user defined applications, user
// defined stages, or user defined objects.
//
//. The two three threads
// that are important to reference are the update thread, and the render thread. The
// update thread is just simply the main thread of the application proper itself. While
// the app.h class is a user defined application/game which is given a thread of its
// own known as the app thread. It is generated from the main/update thread. The reason
// the application-proper main thread becomes the update thread is because when it comes
// to the handling of inputs and windowing events. The creation and destruction of GLFW
// window handles must also be handled by the main thread. 
//
// update thread: The update thread is the application proper main thread (i.e. the thread
// which calls the main function). The reason the application-proper main thread becomes 
// the update thread is because when it comes to the handling of inputs and windowing events. 
// The creation and destruction of GLFW window handles must also be handled by the main thread.
// The update thread is also responsible for iterating through all stages owned by the user
// defined app.h derived class. The user defined derived app class will contain a collection
// of stages which will be iterated through by the update thread. The update thread will 
// perform all update operations to all stages and their respective objects they own. The
// order of operations in which the update thread is supposed to operate is that:
// 1. Process all waiting window creation and destruction events.
// 2. Process all waiting input events.
// 3. It will update the user defined app, iterating through all stages and objects owned by the app.
// 4. It will then query all Transfer & Compute vulkan commands from all stages & objects.
// 5. It will then execute all aggregate Transfer & Compute vulkan commands.
// The update thread also has timestep enforcement such that if the update thread finishes
// its work early, say before the timestep has been reached, the thread will be put to sleep.
// If it finishes late, it will then use the extended timestep in the update calculations. The
// update thread is not only responsible for updating all stages and objects in time, but it is
// also responsible for performing per-stage phys operations. Examples are rigid body dynamics
// and collisions.
//
// render thread: The render thread is responsible for gathering all vulkan Graphics & Compute
// commands, along with presentation commands to be executed by the vulkan device and context.
//
// app thread: The app thread, not to be confused with the main thread, is the thread which is
// spawned from the main/update thread that will be handed off to the user defined app derived
// class at runtime. The engine (update and render thread) is designed to do most of the heavy 
// lifting, while the app thread is left for the user app to use for custom lgc.
//

namespace geodesy {

	class engine {
	public:

		static bool initialize();
		static void terminate();

		// ----- Host Data ----- //

		std::mutex																Mutex;
		std::string 															Name;
		core::math::vec<uint, 3> 												Version;
		core::util::log															Logger;
		core::io::file::manager													FileManager;
		core::lgc::thread_controller											ThreadController;

		// ----- GPU ----- //

		VkInstance																Handle;
		std::vector<std::shared_ptr<bltn::obj::system_display>> 				Display;
		std::vector<std::shared_ptr<core::gcl::device>>							Device;
		std::shared_ptr<bltn::obj::system_display>								PrimaryDisplay;
		std::shared_ptr<core::gcl::device>										PrimaryDevice;
		std::set<std::shared_ptr<core::gcl::context>>							Context;

		engine();
		engine(std::vector<const char*> aCommandLineArgumentList, std::set<std::string> aLayerList, std::set<std::string> aExtensionList);
		~engine();

		std::shared_ptr<core::gcl::context> create_device_context(std::shared_ptr<core::gcl::device> aDevice, std::vector<uint> aOperationBitfieldList, std::set<std::string> aLayerList = {}, std::set<std::string> aExtensionList = {});
		void destroy_device_context(std::shared_ptr<core::gcl::context> aDeviceContext);
		VkResult wait_on_device_context(std::vector<std::shared_ptr<core::gcl::context>> aDeviceContextList = {});

		void run(ecs::app* aApp);
		VkResult update_resources(ecs::app* aApp);
		VkResult execute_render_operations(ecs::app* aApp);

	};

}

#endif // !GEODESY_ENGINE_H
