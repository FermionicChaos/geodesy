#version 460
#extension GL_EXT_ray_tracing : require

// this shader launches a ray into the direction of each light source checking for intersections.
// If an intersection is found, the pixel is in shadow, if not, the pixel is illuminated by the light source.

#define MAX_STAGE_TEXTURES 1024
#define MAX_STAGE_MATERIALS 32
#define MAX_STAGE_LIGHTS 192

#define AMBIENT 1
#define DIRECTIONAL 2
#define POINT 3
#define SPOT 4
#define AREA 5

const float pi = 3.14159265359;

struct payload {
	vec3 Origin;
	vec3 Direction;
	int Hit;
	int HitInstanceID;
	vec3 HitLocation;
	vec2 UV;
	int MaterialIndex;
};

// Standard material info struct
struct material {
	int 	Transparency;
	float 	AlbedoVertexWeight;
	float 	AlbedoTextureWeight;
	float 	AlbedoWeight;
	int 	AlbedoTextureIndex;
	vec3 	Albedo;
	float 	OpacityTextureWeight;
	float 	OpacityWeight;
	int 	OpacityTextureIndex;
	float 	Opacity;
	float 	NormalVertexWeight;
	float 	NormalTextureWeight;
	int 	NormalTextureIndex;
	int 	HeightTextureIndex;
	float 	HeightScale;
	int 	HeightStepCount;
	float 	AmbientLightingTextureWeight;
	float 	AmbientLightingWeight;
	int 	AmbientLightingTextureIndex;
	vec3 	AmbientLighting;
	float 	EmissiveTextureWeight;
	float 	EmissiveWeight;
	int 	EmissiveTextureIndex;
	vec3 	Emissive;
	float 	SpecularTextureWeight;
	float 	SpecularWeight;
	int 	SpecularTextureIndex;
	vec3 	Specular;
	float 	ShininessTextureWeight;
	float 	ShininessWeight;
	int 	ShininessTextureIndex;
	float 	Shininess;
	float 	AmbientOcclusionTextureWeight;
	float 	AmbientOcclusionWeight;
	int 	AmbientOcclusionTextureIndex;
	float 	AmbientOcclusion;
	float 	MetallicTextureWeight;
	float 	MetallicWeight;
	int 	MetallicTextureIndex;
	float 	Metallic;
	float 	RoughnessTextureWeight;
	float 	RoughnessWeight;
	int 	RoughnessTextureIndex;
	float 	Roughness;
	float 	IORVertexWeight;
	float 	IORTextureWeight;
	float 	IORWeight;
	int 	IORTextureIndex;
	float 	IOR;
	float 	SheenColorTextureWeight;
	float 	SheenColorWeight;
	int 	SheenColorTextureIndex;
	vec3 	SheenColor;
	float 	SheenIntensityTextureWeight;
	float 	SheenIntensityWeight;
	float 	SheenRoughnessTextureWeight;
	float 	SheenRoughnessWeight;
	int 	SheenMaskTextureIndex;
	float 	SheenRoughness;
	float 	SheenIntensity;
	float 	ClearCoatStrengthTextureWeight;
	float 	ClearCoatStrengthWeight;
	float 	ClearCoatRoughnessTextureWeight;
	float 	ClearCoatRoughnessWeight;
	int 	ClearCoatStrengthRoughnessTextureIndex;
	float 	ClearCoatStrength;
	float 	ClearCoatRoughness;
	float 	ClearCoatNormalTextureWeight;
	float 	ClearCoatNormalWeight;
	int 	ClearCoatNormalTextureIndex;
	vec3 	ClearCoatNormal;
	float 	ClearCoatTintTextureWeight;
	float 	ClearCoatTintWeight;
	int 	ClearCoatTintTextureIndex;
	vec3 	ClearCoatTint;
	float 	ClearCoatIOR;
	float 	ClearCoatThickness;
};

struct light {
	int 	Type;
	float 	Intensity;
	vec3 	Color;
	vec3 	Position;
	vec3 	Direction;
	float 	SpotAngle;
};

// Ray Payload
layout(location = 0) rayPayloadEXT payload Ray;
// Scene Geometry
layout(set = 0, binding = 0) uniform accelerationStructureEXT TLAS;
// Scene Material Textures
layout(set = 0, binding = 1) uniform sampler2D MaterialColor[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 2) uniform sampler2D MaterialOpacity[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 3) uniform sampler2D MaterialNormalMap[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 4) uniform sampler2D MaterialHeightMap[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 5) uniform sampler2D MaterialEmissive[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 6) uniform sampler2D MaterialSpecular[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 7) uniform sampler2D MaterialShininess[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 8) uniform sampler2D MaterialAmbientOcclusion[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 9) uniform sampler2D MaterialRoughness[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 10) uniform sampler2D MaterialMetallic[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 11) uniform sampler2D MaterialSheen[MAX_STAGE_TEXTURES];
layout(set = 0, binding = 12) uniform sampler2D MaterialClearCoat[MAX_STAGE_TEXTURES];
// Full materials for every mesh instace in the scene.
layout(set = 0, binding = 13) uniform MaterialUBO {
	material Data[MAX_STAGE_MATERIALS];
	int Count;
} Material;
// Deferred shading for light sources for both lighting and shadows.
layout(set = 0, binding = 14) uniform LightUBO {
	light Source[MAX_STAGE_LIGHTS];
	int Count;
} Light;
// Geometry Buffer Data
layout(set = 1, binding = 0, rgba32f) uniform image2D OutputColor;
layout(set = 1, binding = 1) uniform sampler2D PixelColor;
layout(set = 1, binding = 2) uniform sampler2D PixelPosition;
layout(set = 1, binding = 3) uniform sampler2D PixelNormal;
layout(set = 1, binding = 4) uniform sampler2D PixelTangent;
layout(set = 1, binding = 5) uniform sampler2D PixelBitangent;
layout(set = 1, binding = 6) uniform sampler2D PixelORM;
layout(set = 1, binding = 7) uniform sampler2D PixelEmissive;
layout(set = 1, binding = 8) uniform sampler2D PixelTranslucencyMask;
// Camera Data
layout (set = 2, binding = 0) uniform SubjectUBO {
	vec3 Position;
	mat4 Rotation;
	mat4 Projection;
	mat4 PRT;
} Subject;

// ----- PBR Rendering Functions ----- //

// SSAO sample kernel - 16 hemisphere-distributed samples (properly randomized)
const vec3 SSAOKernel[16] = vec3[](
	vec3( 0.2024, -0.8954,  0.3948), vec3(-0.1169,  0.2165,  0.9692),
	vec3(-0.6740, -0.1311,  0.7267), vec3( 0.8334, -0.4512,  0.3221),
	vec3(-0.3477,  0.7865,  0.5115), vec3( 0.5892,  0.6154,  0.5226),
	vec3(-0.8423, -0.4981,  0.2032), vec3( 0.1456, -0.2873,  0.9467),
	vec3( 0.7721,  0.1247,  0.6220), vec3(-0.5234,  0.5912,  0.6137),
	vec3( 0.3891, -0.6743,  0.6280), vec3(-0.7854, -0.2134,  0.5821),
	vec3( 0.6751,  0.4892,  0.5511), vec3(-0.2765, -0.5437,  0.7912),
	vec3( 0.4523,  0.8621,  0.2277), vec3(-0.6128, -0.7234,  0.3194)
);
// SSAO parameters
const float SSAORadius = 0.5;        // Sample radius in world units
const float SSAOBias = 0.025;        // Bias to prevent self-occlusion
const int SSAOSamples = 16;          // Number of samples (matches kernel size)
const float SSAOStrength = 1.0;      // Overall SSAO effect strength

float screen_space_ambient_occlusion(
	vec2 aUV, 
	vec3 aWorldPosition,
	vec3 aWorldNormal
) {	
	float Occlusion = 0.0;
	float CurrentDepth = length(aWorldPosition - Subject.Position);
	
	// Create TBN matrix to orient samples in hemisphere around surface normal
	vec3 RandomVec = normalize(vec3(
		fract(sin(dot(aUV, vec2(12.9898, 78.233))) * 43758.5453),
		fract(sin(dot(aUV, vec2(93.9898, 47.233))) * 43758.5453),
		0.0
	));
	
	vec3 Tangent = normalize(RandomVec - aWorldNormal * dot(RandomVec, aWorldNormal));
	vec3 Bitangent = cross(aWorldNormal, Tangent);
	mat3 TBN = mat3(Tangent, Bitangent, aWorldNormal);
	
	// Sample surrounding pixels
	for (int i = 0; i < SSAOSamples; i++) {
		// Get sample position in world space
		vec3 SampleDirection = TBN * SSAOKernel[i];
		vec3 SamplePosition = aWorldPosition + SampleDirection * SSAORadius;
		
		// Project sample position to screen space
		vec4 SampleScreen = Subject.PRT * vec4(SamplePosition, 1.0);
		SampleScreen.xyz /= SampleScreen.w;
		SampleScreen.xyz = SampleScreen.xyz * 0.5 + 0.5; // Convert from [-1,1] to [0,1]
		
		// Check if sample is within screen bounds
		if (SampleScreen.x < 0.0 || SampleScreen.x > 1.0 || 
			SampleScreen.y < 0.0 || SampleScreen.y > 1.0) {
			continue;
		}
		
		// Sample the depth at this screen position
		vec3 SampleWorldPos = texture(PixelPosition, SampleScreen.xy).xyz;
		float SampleDepth = length(SampleWorldPos - Subject.Position);
		
		// Check if sample is closer to camera (occluding current pixel)
		float DepthDifference = CurrentDepth - SampleDepth;
		
		// Apply range check and bias to prevent self-occlusion artifacts
		if (DepthDifference > SSAOBias && DepthDifference < SSAORadius) {
			// Calculate occlusion factor based on how much closer the sample is
			float RangeCheck = smoothstep(0.0, 1.0, SSAORadius / abs(DepthDifference));
			Occlusion += RangeCheck;
		}
	}
	
	// Normalize occlusion and invert (1.0 = no occlusion, 0.0 = full occlusion)
	Occlusion = 1.0 - (Occlusion / float(SSAOSamples));
	
	// Apply strength and ensure occlusion is in valid range
	return clamp(pow(Occlusion, SSAOStrength), 0.0, 1.0);
}

// Ultra-fast bloom with fixed sample pattern
vec3 bloom(vec2 aScreenUV, vec2 aResolution) {
	// Optimized bloom parameters
	const float BloomRadius = 4.0;        // Much smaller radius
	const float BloomIntensity = 1.5;     // Increased intensity to compensate
	const float BloomThreshold = 0.2;     // Higher threshold
	
	vec3 BloomColor = vec3(0.0);
	int SampleCount = 0;
	
	// Fixed 5x5 sampling pattern (25 samples total)
	vec2 PixelSize = 1.0 / aResolution;
	
	// Unrolled loops for better GPU performance
	for (int x = -2; x <= 2; x++) {
		for (int y = -2; y <= 2; y++) {
			vec2 SampleUV = aScreenUV + vec2(float(x), float(y)) * PixelSize * BloomRadius;
			
			// Skip bounds check for inner samples (assume most are valid)
			if (abs(x) <= 1 && abs(y) <= 1) {
				vec3 SampleEmissive = texture(PixelEmissive, SampleUV).rgb;
				float Luminance = dot(SampleEmissive, vec3(0.299, 0.587, 0.114));
				
				if (Luminance > BloomThreshold) {
					BloomColor += SampleEmissive;
					SampleCount++;
				}
			} else {
				// Only check bounds for edge samples
				if (SampleUV.x >= 0.0 && SampleUV.x <= 1.0 && SampleUV.y >= 0.0 && SampleUV.y <= 1.0) {
					vec3 SampleEmissive = texture(PixelEmissive, SampleUV).rgb;
					float Luminance = dot(SampleEmissive, vec3(0.299, 0.587, 0.114));
					
					if (Luminance > BloomThreshold) {
						BloomColor += SampleEmissive;
						SampleCount++;
					}
				}
			}
		}
	}
	
	// Simple average with intensity boost
	return SampleCount > 0 ? (BloomColor / float(SampleCount)) * BloomIntensity : vec3(0.0);
}

float normal_distribution(float aNdotH, float aRoughness) {
	// Defines the specular highlight of light reflection.
	float a = aRoughness * aRoughness;  // Squared roughness (alpha^2)
	
	// Compute GGX denominator (squared term in denominator)
	float aDenom = ((aNdotH * aNdotH) * (a - 1.0) + 1.0);
	
	// Compute GGX normal distribution function
	return (a / (pi * aDenom * aDenom)); // Correct squaring of denominator
}

float geometric_attenuation(float aHdotN, float aVdotH, float aNdotV, float aNdotL) {
	return min(1.0, min(2.0 * aHdotN * aNdotV / aVdotH, 2.0 * aHdotN * aNdotL / aVdotH));
}

float fresnel_schlick(float aVdotH, float aF0) {
	float Factor = 1.0 - aVdotH;
	float Factor5 = Factor * Factor * Factor * Factor * Factor; // Faster than pow()
	return aF0 + (1.0 - aF0) * Factor5;
}

float rs(vec3 aL, vec3 aN, vec3 aV, float aRoughness, float aMetallic) {
	// Load onto stack for multi usage.
	vec3 h = normalize(aL + aV);
	float HdotN = max(dot(h, aN), 0.001);
	float VdotH = max(dot(aV, h), 0.001);
	float NdotV = max(dot(aN, aV), 0.001);
	float NdotL = max(dot(aN, aL), 0.001);
	float F0 = mix(0.04, 1.0, aMetallic);

	// Check if surface faces the light before calculating specular
	if (NdotL < 0.0) {
		return 0.0; // No specular contribution for back-facing surfaces
	}

	// Load cook torrance terms.
	float D = normal_distribution(dot(aN, h), aRoughness);
	float G = geometric_attenuation(HdotN, VdotH, NdotV, NdotL);
	float F = fresnel_schlick(dot(h, aV), F0);

	// return full specular term of the BRDF.
	return (D * G * F) / (4.0 * NdotL * NdotV);
}

vec3 lighting_and_shadows(
	light aLight, 
	vec4 aAlbedo, 
	vec3 aPixelPosition, 
	vec3 aPixelNormal, 
	vec3 aViewDirection,
	float aAmbientOcclusion,
	float aRoughness,
	float aMetallic
) {
	vec3 LightContribution = vec3(0.0);
	switch (aLight.Type) {
	case AMBIENT:
		// Ambient light affects all surfaces equally, modulated by AO
		LightContribution = aAlbedo.rgb * aLight.Color * aLight.Intensity * aAmbientOcclusion;
		break;
	case DIRECTIONAL: {
			// Light Direction Vector
			vec3 LightDirection = normalize(-aLight.Direction);

			// Check if surface faces the light (back-face culling for lighting)
			float NdotL = dot(aPixelNormal, LightDirection);
			if (NdotL <= 0.0) break; // Surface facing away from light

			// Calculate the half vector for specular calculations
			vec3 HalfVector = normalize(LightDirection + aViewDirection);

			// Directional light is treated as a ray with infinite distance. Ray tracing should check for intersection with geometry.
			// If no intersection, the pixel is illuminated by the light source.
			// Ray.Origin = WorldPosition + WorldNormal * 0.001;
			// Ray.Direction = normalize(Light.Source[i].Direction);
			// Ray.Hit = 0;

			// ! Disabled for Raytracing debugging
			// Trace shadow ray to check for occlusion
			// traceRayEXT(
			// 	TLAS,
			// 	gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
			// 	0xFF,
			// 	0, 0, 0,
			// 	Ray.Origin,
			// 	0.0,
			// 	Ray.Direction,
			// 	LightDistance,
			// 	0
			// );

			// If light is obstructed, skip lighting calculation
			// if (Ray.Hit == 1) break; // If hit, skip lighting calculation

			// Calculate light attenuation (linear falloff for better visuals)
			// Use 1/r instead of 1/r² for more gradual, artistic falloff
			float Attenuation = aLight.Intensity;

			// Calculate diffuse term (Lambertian)
			vec3 Diffuse = aAlbedo.rgb * NdotL;

			// Calculate specular term using PBR (only after confirming surface faces light)
			vec3 Specular = vec3(rs(LightDirection, aPixelNormal, aViewDirection, aRoughness, aMetallic));

			// Combine diffuse and specular based on metallic workflow
			vec3 F0 = mix(vec3(0.04), aAlbedo.rgb, aMetallic); // Base reflectance
			vec3 kS = vec3(fresnel_schlick(max(dot(HalfVector, aViewDirection), 0.0), F0.r));
			vec3 kD = (vec3(1.0) - kS) * (1.0 - aMetallic); // Metallic surfaces have no diffuse

			// Apply AO to the final combined result for indirect/bounce lighting approximation
			LightContribution = (kD*Diffuse) * aLight.Color * Attenuation * aAmbientOcclusion; // Disable specular for directional light
		}
		break;
	case POINT: 
	case SPOT:
	case AREA: {
			// Light Direction Vector
			vec3 LightDirection = aLight.Position - aPixelPosition;
			// Distance to light source
			float LightDistance = length(LightDirection);
			// Normalize the light direction vector
			LightDirection = normalize(LightDirection);

			// Check if surface faces the light (back-face culling for lighting)
			float NdotL = dot(aPixelNormal, LightDirection);
			if (NdotL <= 0.0) break; // Surface facing away from light

			// Calculate the half vector for specular calculations
			vec3 HalfVector = normalize(LightDirection + aViewDirection);

			// Directional light is treated as a ray with infinite distance. Ray tracing should check for intersection with geometry.
			// If no intersection, the pixel is illuminated by the light source.
			// Ray.Origin = WorldPosition + WorldNormal * 0.001;
			// Ray.Direction = normalize(Light.Source[i].Direction);
			// Ray.Hit = 0;

			// ! Disabled for Raytracing debugging
			// Trace shadow ray to check for occlusion
			// traceRayEXT(
			// 	TLAS,
			// 	gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
			// 	0xFF,
			// 	0, 0, 0,
			// 	Ray.Origin,
			// 	0.0,
			// 	Ray.Direction,
			// 	LightDistance,
			// 	0
			// );

			// If light is obstructed, skip lighting calculation
			// if (Ray.Hit == 1) break; // If hit, skip lighting calculation

			// Calculate light attenuation (linear falloff for better visuals)
			// Use 1/r instead of 1/r² for more gradual, artistic falloff
			float Attenuation = aLight.Intensity / LightDistance;

			// Calculate diffuse term (Lambertian)
			vec3 Diffuse = aAlbedo.rgb * NdotL;

			// Calculate specular term using PBR (only after confirming surface faces light)
			vec3 Specular = vec3(rs(LightDirection, aPixelNormal, aViewDirection, aRoughness, aMetallic));

			// Combine diffuse and specular based on metallic workflow
			vec3 F0 = mix(vec3(0.04), aAlbedo.rgb, aMetallic); // Base reflectance
			vec3 kS = vec3(fresnel_schlick(max(dot(HalfVector, aViewDirection), 0.0), F0.r));
			vec3 kD = (vec3(1.0) - kS) * (1.0 - aMetallic); // Metallic surfaces have no diffuse

			// Apply AO to the final combined result for indirect/bounce lighting approximation
			LightContribution = (kD*Diffuse + kS*Specular) * aLight.Color * Attenuation;
		}
		break;
	default:
		// Unknown light source type, skip lighting calculation.
		break;
	}
	return LightContribution;
}

void main() {
	// CRITICAL: Initialize ray payload before ANY traceRayEXT calls
	Ray.Origin = vec3(0.0);
	Ray.Direction = vec3(0.0);
	Ray.Hit = 0;
	Ray.HitInstanceID = 0;  // Initialize to 0, miss shader will set to -1
	Ray.HitLocation = vec3(0.0);
	Ray.UV = vec2(0.0);
	Ray.MaterialIndex = 0;

	// Get Index per ray.
	vec3 FinalColor = vec3(0.0, 0.0, 0.0);
	ivec2 RayIndex = ivec2(gl_LaunchIDEXT.xy);
	ivec2 Resolution = ivec2(gl_LaunchSizeEXT.xy);
	vec2 UV = vec2(RayIndex) / vec2(Resolution);

	// Load G-buffer data
	vec4 Albedo = texture(PixelColor, UV);
	vec3 WorldPosition = texture(PixelPosition, UV).xyz;
	// Decode normal vector from [0,1] range back to [-1,1] range
	// Formula: normal = (encoded * 2.0) - 1.0
	vec3 EncodedNormal = texture(PixelNormal, UV).xyz;
	vec3 WorldNormal = normalize((EncodedNormal * 2.0) - vec3(1.0));
	float AmbientOcclusion = texture(PixelORM, UV).r;
	float Roughness = texture(PixelORM, UV).g;
	float Metallic = texture(PixelORM, UV).b;
	vec3 Emissive = texture(PixelEmissive, UV).rgb;
	float TranslucencyMask = texture(PixelTranslucencyMask, UV).r*0.0f; // Disable translucency for now

	// View direction of the camera.
	vec3 ViewDir = normalize(Subject.Position - WorldPosition);

	// Apply SSAO
	// AmbientOcclusion *= screen_space_ambient_occlusion(UV, WorldPosition, WorldNormal);

	// Blur Emissive Color to create bloom effect
	// Emissive += bloom(UV, vec2(Resolution));

	// Ray origin will start at the world position of the fragment.
	Ray.Origin = WorldPosition;

	// Iterate through each light source adding contributions per light source based on intersection with object in TLAS.
	for (int i = 0; i < Light.Count; i++) {
		// TODO: Implement later.
		// Check Translucency Mask
		if (TranslucencyMask == 0.0) {
			// Use Ray Tracing for basic lighting and shadows.
			FinalColor += lighting_and_shadows(
				Light.Source[i], 
				Albedo, 
				WorldPosition,
				WorldNormal, 
				ViewDir,
				AmbientOcclusion,
				Roughness,
				Metallic
			);
		}
		else {
			// Use Full Ray Tracing for Translucent Materials
		}
	}
	
	// Add direct emissive contribution (for immediate glow)
	FinalColor += 2.0*Emissive;

	// Apply gamma correction to the final color
	FinalColor = pow(FinalColor, vec3(1.0 / 2.2)); // Gamma correction

	// Write the final color per pixel to the output color image.
	imageStore(OutputColor, RayIndex, vec4(FinalColor, 1.0));
	
	// Debug options - uncomment one of these to visualize different aspects:
	// imageStore(OutputColor, RayIndex, Albedo); // Store original albedo for debugging
	// imageStore(OutputColor, RayIndex, vec4(SSAOFactor, SSAOFactor, SSAOFactor, 1.0)); // SSAO visualization
	// imageStore(OutputColor, RayIndex, vec4(AmbientOcclusion, AmbientOcclusion, AmbientOcclusion, 1.0)); // Combined AO visualization
}