#version 460
#extension GL_EXT_ray_tracing : require

#define MAX_SCENE_LIGHTS 256
#define MAX_SCENE_MATERIALS 256

const float pi = 3.14159265359;
const int MAX_BOUNCES = 16;
const float RAY_TMIN = 0.001;
const float RAY_TMAX = 10000.0;
const float AIR_IOR = 1.0;

struct light {
	int Type;
	vec3 Color;
	vec3 Position;
	vec3 Direction;
};

struct material {
	// Material Metadata
	int Type;
	// Albedo
	float AlbedoVertexWeight;
	float AlbedoTextureWeight;
	float AlbedoColorWeight;
	int AlbedoTextureIndex;
	vec3 Albedo;
	// Opacity
	float OpacityTextureWeight;
	float OpacityWeight;
	int OpacityTextureIndex;
	float Opacity;
	// Normal Vector Properties
	float NormalVertexWeight;
	float NormalTextureWeight;
	int NormalTextureIndex;
	// Height Map
	int HeightTextureIndex;
	float HeightScale;
	int HeightStepCount;
	// Emissive
	float EmissiveTextureWeight;
	float EmissiveWeight;
	int EmissiveTextureIndex;
	vec3 Emissive;
	// Specular
	float SpecularTextureWeight;
	float SpecularWeight;
	int SpecularTextureIndex;
	vec3 Specular;
	// Shininess
	float ShininessTextureWeight;
	float ShininessWeight;
	int ShininessTextureIndex;
	float Shininess;
	// AOC/Metallic/Roughness
	int ARMTextureIndex;
	float AmbientOcclusionTextureWeight;
	float AmbientOcclusionWeight;
	float AmbientOcclusion;
	float RoughnessTextureWeight;
	float RoughnessWeight;
	float Roughness;
	float MetallicTextureWeight;
	float MetallicWeight;
	float Metallic;
	// Refraction Properties
	float IORVertexWeight;			// Not Supported
	float IORTextureWeight; 		// Not Supported yet
	float IORWeight;				// Default Material Property
	int IORTextureIndex; 			// -1
	float IOR; 						// Material Property.
	// Sheen
	float SheenColorTextureWeight;
	int SheenColorTextureIndex;
	float SheenColorWeight;
	vec3 SheenColor;
	float SheenMaskTextureWeight; // Containts Roughness & Intensity
	int SheenMaskTextureIndex;
	float SheenMaskWeight;
	float SheenRoughness;
	float SheenIntensity;
	// Clear Coat
	float ClearCoatFactorRoughnessTextureWeight;
	int ClearCoatFactorRoughnessTextureIndex;
	float ClearCoatFactorRoughnessWeight;
	float ClearCoatFactor;
	float ClearCoatRoughness;
	float ClearCoatNormalTextureWeight;
	int ClearCoatNormalTextureIndex;
	float ClearCoatNormalWeight;
	vec3 ClearCoatNormal;
	float ClearCoatTintTextureWeight;
	int ClearCoatTintTextureIndex;
	float ClearCoatTintWeight;
	vec3 ClearCoatTint;
	float ClearCoatIOR;
	float ClearCoatThickness;
	// TODO: Anistropic Properties
	// TODO: Subsurface Scattering
	// float SubsurfaceScattering;
};

struct payload {
    vec3 Origin;
    vec3 Direction;
    int Hit; // 1 if hit, 0 if not
    int HitInstanceID; // Instance ID of the geometry hit
    vec3 HitLocation; // Where the ray hit in world space
};

// Ray Payload
layout(location = 0) rayPayloadEXT payload Ray;
// Scene Geometry
layout(set = 0, binding = 0) uniform accelerationStructureEXT TLAS;
// Final Output Color of the scene.
layout(set = 0, binding = 1, rgba8) uniform image2D OutputColor;

layout (set = 1, binding = 0) uniform Camera3DUBO {
	vec3 Position;
	mat4 Rotation;
	mat4 Projection;
} Camera3D;

// Light sources for illumination calculations
layout(set = 1, binding = 1) uniform LightData {
	vec4 AmbientLight; 					// rgb = color, a = intensity
	light Light[MAX_SCENE_LIGHTS]; 		// Array of light sources
	int LightCount; 					// Number of light sources (up to MAX_SCENE_LIGHTS)
} Lights;

// Full materials for every mesh instace in the scene.
layout(set = 1, binding = 2) buffer GlobalMaterialBuffer {
	struct material Material[];
};

// Calculate refraction direction using Snell's law
vec3 refract_ray(vec3 aIncident, vec3 aNormal, float aIORFrom, float aIORTo) {
	float eta = aIORFrom / aIORTo;
	float cos_i = -dot(aIncident, aNormal);
	float sin_t2 = eta * eta * (1.0 - cos_i * cos_i);
	
	if (sin_t2 >= 1.0) {
		// Total internal reflection
		return reflect(aIncident, aNormal);
	}
	
	float cos_t = sqrt(1.0 - sin_t2);
	return eta * aIncident + (eta * cos_i - cos_t) * aNormal;
}

void main() {
	ivec2 RayIndex = ivec2(gl_LaunchIDEXT.xy);
	ivec2 Resolution = imageSize(OutputColor);

	// We will calculate first based on how many bounces.
	for (size_t i = 0; i < MAX_BOUNCES; i++) {

		// Launch ray into scene from origin, and find intersection with geometry.
		traceRayEXT(
			TLAS,
			gl_RayFlagsOpaqueEXT,
			0xFF,
			0, 0, 0,					// ! Shader Binding Table Stuff, fix later
			RAY_TMIN,
			Ray.Origin,
			RAY_TMAX,					// TODO: Maybe change to farthest point in the scene.
			Ray.Direction,
			0
		);

		// No hit, stop tracing.
		if (Ray.Hit == 0) break;

		// Now check if ray has hit an opaque material.
		material InstanceMaterial = GlobalMaterialBuffer.Material[Ray.HitInstanceID];
	}
	
	// Store final color
	imageStore(OutputColor, RayIndex, vec4(AccumulatedColor, 1.0));
}